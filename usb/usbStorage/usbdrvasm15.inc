/* Имя: usbdrvasm15.inc
 * Проект: AVR USB driver
 * Автор: пожертвовано V. Bosch
 * Перевод: microsin.ru 
 * Дата создания: 2007-08-06
 * Табуляция: 4
 * Copyright: (c) 2007 by OBJECTIVE DEVELOPMENT Software GmbH
 * Лицензия: GNU GPL v2 (см. License.txt) или проприетарная (CommercialLicense.txt)
 * Ревизия: $Id: usbdrvasm15.inc 607 2008-05-13 15:57:28Z cs $
 */

/* Не линкуйте этот файл! Вместо этого линкуйте usbdrvasm.S, который делает include
 *  файла с нужной реализацией (зависящей от тактовой частоты)!
 */

/*
Основное описание:
Этот файл является 15 МГц версией ассемблерной части драйвера USB. Он требует
кристалла 15 МГц (не керамического резонатора и не калиброванного RC-генератора).

См. usbdrv.h для общего описания драйвера.

Поскольку почти весь код критичен по времени выполнения, не меняйте его, если Вы
не представляете полностью, что делаете! Некоторые части не только требуют максимальное
количесво циклов CPU, но и точное количество циклов!
*/

;максимальное использование стека: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 байт
;номинальная частота: 15 МГц -> 10.0 циклов на бит, 80.0 циклов на байт
; Числа в скобках означают количество циклов, подсчитанных относительно центра последнего бита sync
; когда инструкция стартует

;----------------------------------------------------------------------------
; порядок сохранения регистров: 
;	YL, SREG [sofError] YH, shift, x1, x2, x3, bitcnt, cnt, x4
;----------------------------------------------------------------------------
USB_INTR_VECTOR:              
    push    YL                   ;2 	push только если нужно синхр. со срезом ASAP
    in      YL, SREG             ;1 
    push    YL                   ;2 
;----------------------------------------------------------------------------
; Синхронизация с паттерном sync:
;
;   паттерн sync-байта (D-) от младшего (LSb) до старшего (MSb) бита: 01010100 [1 = ожидание (idle) = J, 0 = K]
;   sync от J до среза K во время паттерна sync -- использование самых быстрых циклов
;   первая часть не имеет таймаута, поскольку она ожидает IDLE или SE1 (== отключено)
;-------------------------------------------------------------------------------
waitForJ:			 ;- 
    sbis    USBIN, USBMINUS		;1 <-- выборка: ожидание, когда D- == 1
    rjmp    waitForJ			;2 
;-------------------------------------------------------------------------------
; Cледующий код приводит к окну выборки 1/4 бита, которое соответствует спецификации.
;-------------------------------------------------------------------------------
waitForK:			 ;- 
    sbis    USBIN, USBMINUS      ;1 [00] <-- выборка
    rjmp    foundK               ;2 [01]
    sbis    USBIN, USBMINUS	     ;	 <-- выборка
    rjmp    foundK
    sbis    USBIN, USBMINUS	     ;	 <-- выборка
    rjmp    foundK
    sbis    USBIN, USBMINUS	     ;	 <-- выборка
    rjmp    foundK
    sbis    USBIN, USBMINUS	     ;	 <-- выборка
    rjmp    foundK
    sbis    USBIN, USBMINUS	     ;	 <-- выборка
    rjmp    foundK
#if USB_COUNT_SOF
    lds     YL, usbSofCount
    inc     YL
    sts     usbSofCount, YL
#endif  /* USB_COUNT_SOF */
    rjmp    sofError
;------------------------------------------------------------------------------
; {3, 5} после спада на D- средняя задержка: 4 цикла [нам нужно 5 для центрирования выборки]
;   у нас есть 1 бит времени, предназначенный для setup, затем снова производится 
;   выборка. Числа в скобках - циклы от центра первого sync (двойное K) бита 
;   после инструкции
;------------------------------------------------------------------------------
foundK:                          ;- [02]
    lds     YL, usbInputBufOffset;2 [03+04]	цикл tx
    push    YH                   ;2 [05+06]
    clr     YH                   ;1 [07]
    subi    YL, lo8(-(usbRxBuf)) ;1 [08] 	[инициализация цикла rx]
    sbci    YH, hi8(-(usbRxBuf)) ;1 [09] 	[инициализация цикла rx]
    push    shift                ;2 [10+11]
    ser	    shift		 		;1 [12]
    sbis    USBIN, USBMINUS      ;1 [-1] [13] <--выборка: нам нужно 2 бита K [выборка 1 цикла слишком ранняя]
    rjmp    haveTwoBitsK         ;2 [00] [14]
    pop     shift                ;2 	 [15+16] отмена предыдущего push
    pop     YH 			         ;2 	 [17+18] отмена предыдущего push
    rjmp    waitForK             ;2 	 [19+20] это не был конец sync, пробуем еще раз
; Цикл целиком от waitForK до rjmp waitForK выше не должен превышать два бита времени
;  (= 20 циклов).

;----------------------------------------------------------------------------
; сохраняем регистры и инициализируем переменные, когда мы выбираем первые биты:
;----------------------------------------------------------------------------
haveTwoBitsK:					;- [01]
    push    x1              	;2 [02+03]
    push    x2              	;2 [04+05]
    push    x3              	;2 [06+07]
    push    bitcnt				;2 [08+09]	
    in      x1, USBIN       	;1 [00] [10] <-- выбираем бит 0
    bst     x1, USBMINUS    	;1 [01]
    bld     shift, 0        	;1 [02]
    push    cnt             	;2 [03+04]
    ldi     cnt, USB_BUFSIZE	;1 [05] 
    push    x4              	;2 [06+07] цикл tx
    rjmp    rxLoop          	;2 [08]
;----------------------------------------------------------------------------
; Цикл приемника (числа в скобках показывают циклы внутри байта после инструкции)
;----------------------------------------------------------------------------
unstuff0:               	;- [07] (взятый переход)
    andi    x3, ~0x01   	;1 [08]
    mov     x1, x2      	;1 [09] X2 содержит последний выбранный (stuffed) бит
    in      x2, USBIN   	;1 [00] [10] <-- выбираем бит 1 снова
    andi    x2, USBMASK 	;1 [01]
    breq    se0Hop         	;1 [02] SE0 проверка для бита 1 
    ori     shift, 0x01 	;1 [03] 0b00000001
    nop				;1 [04]
    rjmp    didUnstuff0 	;2 [05]
;-----------------------------------------------------
unstuff1:               	;- [05] (взятый переход)
    mov     x2, x1      	;1 [06] x1 содержит последний выбранный (stuffed) бит
    andi    x3, ~0x02   	;1 [07]
    ori     shift, 0x02 	;1 [08] 0b00000010
    nop                 	;1 [09]
    in      x1, USBIN   	;1 [00] [10] <-- выбираем бит 2 снова
    andi    x1, USBMASK 	;1 [01]
    breq    se0Hop         	;1 [02] SE0 проверка для бита 2 
    rjmp    didUnstuff1 	;2 [03]
;-----------------------------------------------------
unstuff2:               	;- [05] (взятый переход)
    andi    x3, ~0x04   	;1 [06]
    ori     shift, 0x04 	;1 [07] 0b00000100
    mov     x1, x2      	;1 [08] x2 содержит последний выбранный (stuffed) бит
    nop                 	;1 [09]
    in      x2, USBIN   	;1 [00] [10] <-- выбираем бит 3
    andi    x2, USBMASK 	;1 [01]
    breq    se0Hop         	;1 [02] SE0 проверка для бита 3 
    rjmp    didUnstuff2 	;2 [03]
;-----------------------------------------------------
unstuff3:               	;- [00] [10] (взятый переход)
    in      x2, USBIN   	;1 [01] [11] <-- выборка stuffed бита 3 один цикл слишком поздно
    andi    x2, USBMASK 	;1 [02]
    breq    se0Hop         	;1 [03] SE0 проверка для stuffed бита 3 
    andi    x3, ~0x08   	;1 [04]
    ori     shift, 0x08 	;1 [05] 0b00001000
    rjmp    didUnstuff3 	;2 [06]
;----------------------------------------------------------------------------
; дополнительные действия, выполняемые на битовых интервалах:
;
; bit 0:    сохранение, очитка [SE0 здесь ненадежен из-за дрибблинга бит в хабах], 
; 		проверка переполнения, переход в начало rxLoop
; bit 1:    проверка SE0
; bit 2:    проверка SE0, восстановление из задержки [задачи бита 0 отнимают слишком много времени]
; bit 3:    проверка SE0, восстановление из задержки [задачи бита 0 отнимают слишком много времени]
; bit 4:    проверка SE0, ничего
; bit 5:    проверка SE0, ничего
; bit 6:    проверка SE0, ничего
; bit 7:    проверка SE0, реконструкция: x3 0 в месторасположении бита, которое мы поменяли, 1 для других
;----------------------------------------------------------------------------
rxLoop:						;- [09]
    in      x2, USBIN   	;1 [00] [10] <-- выборка бита 1 (или возможно stuffed-бит 0)
    andi    x2, USBMASK 	;1 [01]
    brne    SkipSe0Hop		;1 [02]
se0Hop:						;- [02]
    rjmp    se0         	;2 [03] SE0 проверка для бита 1 
SkipSe0Hop:					;- [03]
    ser     x3          	;1 [04]
    andi    shift, 0xf9 	;1 [05] 0b11111001
    breq    unstuff0    	;1 [06]
didUnstuff0:				;- [06]
    eor     x1, x2      	;1 [07]
    bst     x1, USBMINUS	;1 [08]
    bld     shift, 1    	;1 [09] 
    in      x1, USBIN   	;1 [00] [10] <-- выборка бита 2 (или возможно stuffed-бит 1)
    andi    x1, USBMASK 	;1 [01]
    breq    se0Hop         	;1 [02] SE0 проверка для бита 2 
    andi    shift, 0xf3 	;1 [03] 0b11110011
    breq    unstuff1    	;1 [04] делаем оставшуюся работу для бита 1
didUnstuff1:				;- [04]
    eor     x2, x1      	;1 [05]
    bst     x2, USBMINUS	;1 [06]
    bld     shift, 2    	;1 [07]
    nop2					;2 [08+09]
    in      x2, USBIN   	;1 [00] [10] <-- выборка бита 3 (или возможно stuffed-бит 2)
    andi    x2, USBMASK 	;1 [01]
    breq    se0Hop         	;1 [02] SE0 проверка для бита 3 
    andi    shift, 0xe7 	;1 [03] 0b11100111
    breq    unstuff2    	;1 [04]
didUnstuff2:				;- [04]
    eor     x1, x2      	;1 [05]
    bst     x1, USBMINUS	;1 [06]
    bld     shift, 3    	;1 [07]
didUnstuff3:				;- [07]
    andi    shift, 0xcf 	;1 [08] 0b11001111
    breq    unstuff3    	;1 [09]
    in      x1, USBIN   	;1 [00] [10] <-- выборка бита 4
    andi    x1, USBMASK 	;1 [01]
    breq    se0Hop         	;1 [02] SE0 проверка для бита 4
    eor     x2, x1      	;1 [03]
    bst     x2, USBMINUS	;1 [04]
    bld     shift, 4    	;1 [05]
didUnstuff4:				;- [05]
    andi    shift, 0x9f 	;1 [06] 0b10011111
    breq    unstuff4    	;1 [07]
    nop2					;2 [08+09]
    in      x2, USBIN   	;1 [00] [10] <-- выборка бита 5
    andi    x2, USBMASK 	;1 [01]
    breq    se0         	;1 [02] SE0 проверка для бита 5
    eor     x1, x2      	;1 [03]
    bst     x1, USBMINUS	;1 [04]
    bld     shift, 5    	;1 [05]
didUnstuff5:				;- [05]
    andi    shift, 0x3f 	;1 [06] 0b00111111
    breq    unstuff5    	;1 [07]
    nop2					;2 [08+09]
    in      x1, USBIN   	;1 [00] [10] <-- выборка бита 6
    andi    x1, USBMASK 	;1 [01]
    breq    se0         	;1 [02] SE0 проверка для бита 6
    eor     x2, x1      	;1 [03]
    bst     x2, USBMINUS	;1 [04]
    bld     shift, 6   	 	;1 [05]
didUnstuff6:				;- [05]
    cpi     shift, 0x02 	;1 [06] 0b00000010
    brlo    unstuff6    	;1 [07]
    nop2					;2 [08+09]
    in      x2, USBIN   	;1 [00] [10] <-- выборка бита 7
    andi    x2, USBMASK 	;1 [01]
    breq    se0         	;1 [02] SE0 проверка для бита 7
    eor     x1, x2      	;1 [03]
    bst     x1, USBMINUS	;1 [04]
    bld     shift, 7    	;1 [05]
didUnstuff7:				;- [05] 
    cpi     shift, 0x04 	;1 [06] 0b00000100
    brlo    unstuff7		;1 [07]
    eor     x3, shift   	;1 [08] реконструкция: x3 0 в месторасположении бита, которое мы поменяли, 1 для других
    nop				;1 [09]
    in      x1, USBIN   	;1 [00]	[10] <-- выборка бита 0
    st      y+, x3      	;2 [01+02] сохранение данных
    eor     x2, x1      	;1 [03]
    bst     x2, USBMINUS	;1 [04]
    bld     shift, 0    	;1 [05]
    subi    cnt, 1			;1 [06]
    brcs    overflow		;1 [07]
    rjmp    rxLoop			;2 [08]
;-----------------------------------------------------
unstuff4:               	;- [08] 
    andi    x3, ~0x10   	;1 [09]
    in      x1, USBIN   	;1 [00] [10] <-- выборка stuffed бита 4
    andi    x1, USBMASK 	;1 [01]
    breq    se0         	;1 [02] SE0 проверка для stuffed бита 4
    ori     shift, 0x10 	;1 [03]
    rjmp    didUnstuff4 	;2 [04]
;-----------------------------------------------------
unstuff5:               	;- [08] 
    ori     shift, 0x20 	;1 [09]
    in      x2, USBIN   	;1 [00] [10] <-- выборка stuffed бита 5
    andi    x2, USBMASK 	;1 [01]
    breq    se0         	;1 [02] SE0 проверка для stuffed бита 5
    andi    x3, ~0x20   	;1 [03]
    rjmp    didUnstuff5		;2 [04]
;-----------------------------------------------------
unstuff6:               	;- [08] 
    andi    x3, ~0x40   	;1 [09]
    in      x1, USBIN   	;1 [00] [10] <-- выборка stuffed бита 6
    andi    x1, USBMASK 	;1 [01]
    breq    se0         	;1 [02] SE0 проверка для stuffed бита 6
    ori     shift, 0x40 	;1 [03]
    rjmp    didUnstuff6 	;2 [04]
;-----------------------------------------------------
unstuff7:			;- [08]
    andi    x3, ~0x80   	;1 [09]
    in      x2, USBIN   	;1 [00] [10] <-- выборка stuffed бита 7
    andi    x2, USBMASK 	;1 [01]
    breq    se0         	;1 [02] SE0 проверка для stuffed бита 7
    ori     shift, 0x80 	;1 [03]
    rjmp    didUnstuff7 	;2 [04]
    
macro POP_STANDARD ; 16 циклов
    pop     x4    
    pop     cnt
    pop     bitcnt
    pop     x3
    pop     x2
    pop     x1
    pop     shift
    pop     YH
endm
macro POP_RETI     ; 5 циклов
    pop     YL
    out     SREG, YL
    pop     YL
endm

#include "asmcommon.inc"

;---------------------------------------------------------------------------
; спецификация USB говорит:
; idle = J
; J = (D+ = 0), (D- = 1)
; K = (D+ = 1), (D- = 0)
; Спецификация позволяет 7.5 бит от EOP до SOP для ответов
;---------------------------------------------------------------------------
bitstuffN:		    	;- [04]
    eor     x1, x4 		;1 [05]
    clr	    x2			;1 [06]
    nop					;1 [07]
    rjmp    didStuffN   ;1 [08]
;---------------------------------------------------------------------------    
bitstuff6:		    	;- [04]
    eor     x1, x4      ;1 [05]
    clr	    x2			;1 [06]
    rjmp    didStuff6   ;1 [07]
;---------------------------------------------------------------------------
bitstuff7:		    	;- [02]
    eor     x1, x4      ;1 [03]
    clr	    x2			;1 [06]
    nop			    	;1 [05]
    rjmp    didStuff7   ;1 [06]
;---------------------------------------------------------------------------
sendNakAndReti:			;- [-19]
    ldi     x3, USBPID_NAK  	;1 [-18]
    rjmp    sendX3AndReti   	;1 [-17]
;---------------------------------------------------------------------------
sendAckAndReti:			;- [-17]
    ldi     cnt, USBPID_ACK 	;1 [-16]
sendCntAndReti:			;- [-16]
    mov     x3, cnt     ;1 [-15]
sendX3AndReti:			;- [-15]
    ldi     YL, 20      ;1 [-14] x3==r20 адрес равен 20
    ldi     YH, 0       ;1 [-13]
    ldi     cnt, 2      ;1 [-12]
;   rjmp    usbSendAndReti      проваливаемся
;---------------------------------------------------------------------------
;usbSend:
;указатель наданные в 'Y'
;количество байт в 'cnt' -- включая байт sync [диапазон 2 ... 12]
;используются: x1...x4, btcnt, shift, cnt, Y
;числа в скобках определяет время с тех пор, как первый бит синхронизирующего шаблона (sync pattern) послан
;Нам не нужно точно соответствовать скорости передачи, потому что спецификация все равно требует точности 
; только 1.5%.
usbSendAndReti:             	;- [-13] 13 циклов пока не появится SOP
    in      x2, USBDDR      	;1 [-12]
    ori     x2, USBMASK     	;1 [-11]
    sbi     USBOUT, USBMINUS	;2 [-09-10] подготовка состояния ожидания (idle); D+ и D- должны быть в 0 (без нагрузочных резисторов (pullups))
    in      x1, USBOUT      	;1 [-08] зеркалирование порта для цикла передачи (tx)
    out     USBDDR, x2      	;1 [-07] <- получение шины
	; не нужно инициализировать x2 (история bitstuff (вставки неинформационных бит)), поскольку sync стартует с 0
    ldi     x4, USBMASK     	;1 [-06] 	маска exor (исключающее ИЛИ)
    ldi     shift, 0x80     	;1 [-05] 	байт sync - первый из отправляемых байт
    ldi     bitcnt, 6    		;1 [-04] 
txBitLoop:		    			;- [-04] [06]
    sbrs    shift, 0        	;1 [-03] [07]
    eor     x1, x4          	;1 [-02] [08] 
    ror     shift           	;1 [-01] [09]  
didStuffN:		    			;-       [09]
    out     USBOUT, x1      	;1 [00]  [10] <-- вывод N
    ror     x2              	;1 [01]
    cpi     x2, 0xfc        	;1 [02]
    brcc    bitstuffN       	;1 [03]
    dec     bitcnt          	;1 [04]
    brne    txBitLoop       	;1 [05]
    sbrs    shift, 0        	;1 [06]
    eor     x1, x4          	;1 [07]
    ror     shift           	;1 [08]
didStuff6:						;- [08]
    nop							;1 [09]
    out     USBOUT, x1      	;1 [00] [10] <-- вывод 6
    ror     x2              	;1 [01] 
    cpi     x2, 0xfc        	;1 [02]
    brcc    bitstuff6       	;1 [03]
    sbrs    shift, 0        	;1 [04]
    eor     x1, x4          	;1 [05]
    ror     shift           	;1 [06]
    ror     x2              	;1 [07]
didStuff7:						;- [07]
    ldi     bitcnt, 6    		;1 [08]
    cpi     x2, 0xfc        	;1 [09]
    out     USBOUT, x1      	;1 [00] [10] <-- вывод 7
    brcc    bitstuff7       	;1 [01]
    ld      shift, y+       	;2 [02+03]
    dec     cnt             	;1 [04]
    brne    txBitLoop      		;1 [05]
makeSE0:
    cbr     x1, USBMASK     	;1 [06] 	подготовка SE0 [спецификация говорит, что EOP может быть от 19 до 23 циклов]
    lds     x2, usbNewDeviceAddr;2 [07+08]
    lsl     x2                  ;1 [09] мы сравниваем с влево сдвинутым адресом
;2006-03-06: перенесена передача нового адреса в usbDeviceAddr из кода C в ассемблер:
;установка адреса только после того, как пакет данных отправлен, не после рукопожатия (handshake)
    out     USBOUT, x1      	;1 [00] [10] <-- вывод SE0-- теперь от 2 bits==20 циклов пока шина в состоянии ожидания (idle)
    subi    YL, 20 + 2          ;1 [01] только назначает адрес на пакеты данных, нет ACK/NAK в x3
    sbci    YH, 0           	;1 [02]
    breq    skipAddrAssign  	;1 [03]
    sts     usbDeviceAddr, x2	;2 [04+05] если не пропущено: SE0 на один цикл длиннее
;----------------------------------------------------------------------------
;конец передачи usbDeviceAddress
skipAddrAssign:						;- [03/04]
    ldi     x2, 1<<USB_INTR_PENDING_BIT	;1 [05] int0 произошло во время TX -- очистка флага ожидания очереди
    USB_STORE_PENDING(x2)           ;1 [06]
    ori     x1, USBIDLE     		;1 [07]
    in      x2, USBDDR      		;1 [08]
    cbr     x2, USBMASK     		;1 [09] установка обоих ножек на ввод
    mov     x3, x1          		;1 [10]
    cbr     x3, USBMASK     		;1 [11] конфигурируем отсутствие нагрузочных резисторов (pullup) на обоих ножках
    ldi     x4, 3           		;1 [12]
se0Delay:							;- [12] [15] 
    dec     x4              		;1 [13] [16] 
    brne    se0Delay        		;1 [14] [17] 
    nop2							;2      [18+19]
    out     USBOUT, x1      		;1      [20] <--вывод J (idle) -- окончание SE0 (сигнал EOP)
    out     USBDDR, x2      		;1      [21] <--теперь освобождение шины
    out     USBOUT, x3      		;1      [22] <--убедимся в том, что нет активных нагрузочных (pull-up) резисторов
    rjmp    doReturn				;1	[23]
;---------------------------------------------------------------------------
