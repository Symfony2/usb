/* Имя: usbdrvasm20.inc
 * Проект: драйвер AVR USB
 * Автор: Jeroen Benschop
 * Основано на usbdrvasm16.inc от Christian Starkjohann
 * Перевод: microsin.ru 
 * Дата создания: 2008-03-05
 * Табуляция: 4
 * Copyright: (c) 2008 Jeroen Benschop и OBJECTIVE DEVELOPMENT Software GmbH
 * Лицензия: GNU GPL v2 (см. License.txt) или проприетарная (CommercialLicense.txt)
 * Ревизия: $Id: usbdrvasm20.inc 607 2008-05-13 15:57:28Z cs $
 */

/* Не линкуйте этот файл! Вместо этого линкуйте usbdrvasm.S, который делает include
 *  файла с нужной реализацией (зависящей от тактовой частоты)!
 */

/*
Основное описание:
Этот файл является 16 МГц версией ассемблерной части драйвера USB. Он требует
кристалла 16 МГц (не керамического резонатора и не калиброванного RC-генератора).

См. usbdrv.h для общего описания драйвера.

Поскольку почти весь код критичен по времени выполнения, не меняйте его, если Вы
не представляете полностью, что делаете! Некоторые части не только требуют максимальное
количесво циклов CPU, но и точное количество циклов!
*/

#define leap2   x3
#ifdef __IAR_SYSTEMS_ASM__
#define nextInst    $+2
#else
#define nextInst    .+0
#endif

;максимальное использование стека: [ret(2), YL, SREG, YH, bitcnt, shift, x1, x2, x3, x4, cnt] = 12 байт
;номинальная частота: 20 МГц -> 13.333333 циклов на бит, 106.666667 циклов на байт
; Числа в скобках означают количество циклов, подсчитанных относительно центра последнего бита sync
; когда инструкция стартует
;регистры, используемые в цикле приема:
; сдвиг собирает байт, который принимается
; x1 содержит состояние линий D+ и D-
; x2 содержит предыдущее состояние линии
; x4 (leap)  используется для прыжка в цикле один раз каждые 3 принятые байта
; X3 (leap2) используется для прыжка в цикле один раз каждые 3 принятые stuff бита
; bitcnt используется для определения, когда должен быть stuff бит
; cnt содержит количество оставшихся байт в буфере приема

USB_INTR_VECTOR:
;порядок сохранения регистров: YL, SREG YH, [sofError], bitcnt, shift, x1, x2, x3, x4, cnt
    push    YL                  ;[-28] push только если нужно синхр. со срезом ASAP
    in      YL, SREG            ;[-26]
    push    YL                  ;[-25]
    push    YH                  ;[-23]
;----------------------------------------------------------------------------
; Синхронизация с паттерном sync:
;----------------------------------------------------------------------------
;паттерн sync-байта (D-) от младшего (LSb) до старшего (MSb) бита: 01010100 [1 = ожидание (idle) = J, 0 = K]
;sync от J до среза K во время паттерна sync -- использование самых быстрых циклов
;первая часть не имеет таймаута, поскольку она ожидает IDLE или SE1 (== отключено)
waitForJ:
    sbis    USBIN, USBMINUS     ;[-21] ожидание, когда D- == 1
    rjmp    waitForJ
waitForK:
;Cледующий код приводит к окну выборки < 1/4 бита, которое соответствует спецификации.
    sbis    USBIN, USBMINUS     ;[-19]
    rjmp    foundK              ;[-18]
    sbis    USBIN, USBMINUS
    rjmp    foundK
    sbis    USBIN, USBMINUS
    rjmp    foundK
    sbis    USBIN, USBMINUS
    rjmp    foundK
    sbis    USBIN, USBMINUS
    rjmp    foundK
    sbis    USBIN, USBMINUS
    rjmp    foundK
    sbis    USBIN, USBMINUS
    rjmp    foundK
    sbis    USBIN, USBMINUS
    rjmp    foundK
    sbis    USBIN, USBMINUS
    rjmp    foundK
#if USB_COUNT_SOF
    lds     YL, usbSofCount
    inc     YL
    sts     usbSofCount, YL
#endif  /* USB_COUNT_SOF */
    rjmp    sofError
foundK:                         ;[-16]
;{3, 5} после спада на D- средняя задержка: 4 цикла
;бит 0 должен быть возде 34 для центрирования выборки. В настоящий момент от 4 до 30 циклов до выборки бита 0
;Первый бит времени используется для нужд setup, затем снова производится выборка. 
Числа в скобках - циклы от центра первого sync (двойное K) бита после инструкции
    push    bitcnt              ;[-16]
;   [---]                       ;[-15]
    lds     YL, usbInputBufOffset;[-14]
;   [---]                       ;[-13]
    clr     YH                  ;[-12]
    subi    YL, lo8(-(usbRxBuf));[-11] [инициализация цикла rx]
    sbci    YH, hi8(-(usbRxBuf));[-10] [инициализация цикла rx]
    push    shift               ;[-9]
;   [---]                       ;[-8]
    ldi     shift,0x40          ;[-7] установка msb в "1" - так можно определить обработку бита 7
    nop2                        ;[-6]
;   [---]                       ;[-5]
    ldi     bitcnt, 5           ;[-4] [инициализация цикла rx]
    sbis    USBIN, USBMINUS     ;[-3] нам нужно 2 бита K (выборка 3 цикла слишком ранняя)
    rjmp    haveTwoBitsK        ;[-2]
    pop     shift               ;[-1] отмена предыдущего push
    pop     bitcnt              ;[1] 
    rjmp    waitForK            ;[3] это не был конец sync, пробуем еще раз
; Цикл целиком от waitForK до rjmp waitForK выше не должен превышать два бита времени
;  (= 27 циклов).

;----------------------------------------------------------------------------
; сохраняем регистры и инициализируем переменные, когда мы выбираем первые биты:
;----------------------------------------------------------------------------
haveTwoBitsK:
    push    x1                  ;[0]
    push    x2                  ;[2]
    push    x3                  ;[4] (leap2)
    ldi     leap2, 0x55         ;[6] добавим leap цикл на 2, 5, 8, ... stuff битах
    push    x4                  ;[7] == leap
    ldi     leap, 0x55          ;[9] пропуск цикла leap на 2, 5, 8, ... принятом байте
    push    cnt                 ;[10]
    ldi     cnt, USB_BUFSIZE    ;[12] [инициализация цикла rx]
    ldi     x2, 1<<USBPLUS      ;[13] текущее состояние линии - состояние K. D+=="1", D-=="0"
bit0:       
    in      x1, USBIN           ;[0] выборка состояния линии
    andi    x1, USBMASK         ;[1] отфильтруем только биты D+ и D-
    rjmp    handleBit           ;[2] сделаем bit 0 длиной 14 циклов

;----------------------------------------------------------------------------
; Обработка бита 7. Однако, бит 6 еще может быть выбран (unstuffing).
;----------------------------------------------------------------------------

b6checkUnstuff:
    dec     bitcnt              ;[9]
    breq    unstuff6            ;[10]
bit7:
    subi    cnt, 1              ;[11] не можем использовать команду dec, так как она не меняет флаг переноса (carry)
    brcs    overflow            ;[12] Слишком много принятых байт. Игнорируем пакет
    in      x1, USBIN           ;[0] выюорка состояния линии
    andi    x1, USBMASK         ;[1] отфильтруем только биты D+ и D-
    cpse    x1, x2              ;[2] когда предыдущее состояние линии равно текущему, регистрируем "1"
    rjmp    b7handle0           ;[3] когда состояния линии различаются, регистрируем "0"
    sec                         ;[4]
    ror     shift               ;[5] сдвигаем "1" в данные
    st      y+, shift           ;[6] сохраняем данные в буфере
    ldi     shift, 0x40         ;[7] сбрасываем данные для приема следующего байта
    subi    leap, 0x55          ;[9] применение цикла прыжка каждые 3 байта
    brcc    nextInst            ;[10 или 11] здесь произойдет ошибка после 85 байт. Однако по стадарту низкой скорости (low speed) можно принять только 11
    dec     bitcnt              ;[11 или 12]
    brne    bit0                ;[12 или 13]
    ldi     x1, 1               ;[13 или 14] unstuffing бит 7
    in      bitcnt, USBIN       ;[0] выборка stuff-бита
    rjmp    unstuff             ;[1]

b7handle0:
    mov     x2,x1               ;[5] установим x2 в текущее состояние линии
    ldi     bitcnt, 6           ;[6]
    lsr     shift               ;[7] сдвигаем "0" в данные
    st      y+, shift           ;[8] сохраняем данные в буфере
    ldi     shift, 0x40         ;[10] сбрасываем данные для приема следующего байта
    subi    leap, 0x55          ;[11] применение цикла прыжка каждые 3 байта
    brcs    bit0                ;[12] здесь произойдет ошибка после 85 байт. Однако по стадарту низкой скорости (low speed) можно принять только 11
    rjmp    bit0                ;[13]


;----------------------------------------------------------------------------
; Обработка unstuff
; x1==0xFF индицирует unstuffing бит 6
;----------------------------------------------------------------------------

unstuff6:
    ldi     x1,0xFF             ;[12] индицирует unstuffing бит 6
    in      bitcnt, USBIN       ;[0]  выборка stuff бита
    nop                         ;[1]  фиксирование тайминга
unstuff:                        ;b0-5  b6   b7
    mov     x2,bitcnt           ;[3]  [2]  [3]  установим x2 в соответствии с состоянием линии
    subi    leap2, 0x55         ;[4]  [3]  [4]  цикл задержки
    brcs    nextInst            ;[5]  [4]  [5]  и один цикл каждые 3 stuff бита
    sbci    leap2,0             ;[6]  [5]  [6]
    ldi     bitcnt,6            ;[7]  [6]  [7]  сброс счетчика stuff бит
    andi    x2, USBMASK         ;[8]  [7]  [8] сохраняем только D+ и D-
    cpi     x1,0                ;[9]  [8]  [9]
    brmi    bit7                ;[10] [9]  [10] завершение unstuffing бита 6   когда x1<0
    breq    bitloop             ;[11] ---  [11] завершение unstuffing бит  0-5 когда x1=0
    nop                         ;---  ---  [12]
    in      x1, USBIN           ;---  ---  [0] выборка состояния линии для бита 0
    andi    x1, USBMASK         ;---  ---  [1] фильтруем только D+ и D- биты
    rjmp    handleBit           ;---  ---  [2] делаем бит 0 длиной 14 циклов

;----------------------------------------------------------------------------
; Цикл приемника (числа в скобках показывают циклы внутри байта после инструкции)
;----------------------------------------------------------------------------
bitloop:
    in      x1, USBIN           ;[0] выборка состояния линии
    andi    x1, USBMASK         ;[1] фильтруем только биты D+ и D-
    breq    se0                 ;[2] обе линии в состоянии low при регистрации se0
handleBit:
    cpse    x1, x2              ;[3] когда предыдущее состояние линии равно текущему, регистрируем "1"
    rjmp    handle0             ;[4] когда состояния линии различаются, регистрируем "0"
    sec                         ;[5]
    ror     shift               ;[6] вдвигаем "1" в данные
    brcs    b6checkUnstuff      ;[7] когда после сдвига признак переноса C установлен, следующий бит - бит 7
    nop2                        ;[8]
    dec     bitcnt              ;[10]
    brne    bitloop             ;[11]
    ldi     x1,0                ;[12] индикация unstuff для бита, отличного от бита 6 и 7
    in      bitcnt, USBIN       ;[0] выборка stuff бита
    rjmp    unstuff             ;[1]

handle0:
    mov     x2, x1              ;[6] установим x2 в текущее состояние линии
    ldi     bitcnt, 6           ;[7] сброс счетчика unstuff. 
    lsr     shift               ;[8] вдвигаем "0" в данные
    brcs    bit7                ;[9] когда после сдвига признак переноса C установлен, следующий бит - бит 7
    nop                         ;[10]
    rjmp    bitloop             ;[11] 
    
;----------------------------------------------------------------------------
; Конец цикла приема. Теперь запускается обработка EOP
;----------------------------------------------------------------------------

macro POP_STANDARD ; 14 циклов
    pop     cnt
    pop     x4
    pop     x3
    pop     x2
    pop     x1
    pop     shift
    pop     bitcnt
endm
macro POP_RETI     ; 7 циклов
    pop     YH
    pop     YL
    out     SREG, YL
    pop     YL
endm



#include "asmcommon.inc"

; спецификация USB говорит:
; idle = J
; J = (D+ = 0), (D- = 1)
; K = (D+ = 1), (D- = 0)
; Спецификация позволяет 7.5 бит от EOP до SOP для ответов
; 7.5 бит занимают по времени 100 циклов. Эта реализация достигает немного позже se0,
; как определено во включаемом файле, но есть запас времени

bitstuffN:
    eor     x1, x4          ;[8]
    ldi     x2, 0           ;[9]
    nop2                    ;[10]
    out     USBOUT, x1      ;[12] <-- вывод
    rjmp    didStuffN       ;[0]
    
bitstuff7:
    eor     x1, x4          ;[6]
    ldi     x2, 0           ;[7] Carry сброшен поскольку дальше идет команда brcc
    rol     shift           ;[8] компенсация сдвига ror в ветви назначения
    nop2                    ;[9]
    rjmp    didStuff7       ;[11]

sendNakAndReti:
    ldi     x3, USBPID_NAK  ;[-18]
    rjmp    sendX3AndReti   ;[-17]
sendAckAndReti:
    ldi     cnt, USBPID_ACK ;[-17]
sendCntAndReti:
    mov     x3, cnt         ;[-16]
sendX3AndReti:
    ldi     YL, 20          ;[-15] x3==r20 адрес равен 20
    ldi     YH, 0           ;[-14]
    ldi     cnt, 2          ;[-13]
;   rjmp    usbSendAndReti      проваливаемся

;usbSend:
;указатель на данные в 'Y'
;количество байт в 'cnt' -- включая байт sync [диапазон 2 ... 12]
;используются: x1...x4, btcnt, shift, cnt, Y
;числа в скобках определяет время с тех пор, как первый бит синхронизирующего шаблона (sync pattern) послан
;Нам не нужно точно соответствовать скорости передачи, потому что спецификация все равно требует точности 
; только 1.5%.
usbSendAndReti:             ; 12 циклов пока не появится SOP
    in      x2, USBDDR      ;[-12]
    ori     x2, USBMASK     ;[-11]
    sbi     USBOUT, USBMINUS;[-10] подготовка состояния ожидания (idle); D+ и D- должны быть в 0 (без нагрузочных резисторов (pullups))
    in      x1, USBOUT      ;[-8] зеркалирование порта для цикла передачи (tx)
    out     USBDDR, x2      ;[-7] <- получение шины
; не нужно инициализировать x2 (история bitstuff (вставки неинформационных бит)), поскольку sync стартует с 0
    ldi     x4, USBMASK     ;[-6] маска exor (исключающее ИЛИ)
    ldi     shift, 0x80     ;[-5] байт sync - первый из отправляемых байт
txByteLoop:
    ldi     bitcnt, 0x49    ;[-4]        [10] двоичное 01001001
txBitLoop:
    sbrs    shift, 0        ;[-3] [10]   [11]
    eor     x1, x4          ;[-2] [11]   [12]
    out     USBOUT, x1      ;[-1] [12]   [13]   <-- вывод N
    ror     shift           ;[0]  [13]   [14]
    ror     x2              ;[1]
didStuffN:
    nop2                    ;[2]
    nop                     ;[4]
    cpi     x2, 0xfc        ;[5]
    brcc    bitstuffN       ;[6]
    lsr     bitcnt          ;[7]
    brcc    txBitLoop       ;[8]
    brne    txBitLoop       ;[9]

    sbrs    shift, 0        ;[10]
    eor     x1, x4          ;[11]
didStuff7:
    out     USBOUT, x1      ;[-1] [13] <-- вывод 7
    ror     shift           ;[0] [14]
    ror     x2              ;[1]
    nop                     ;[2]
    cpi     x2, 0xfc        ;[3]
    brcc    bitstuff7       ;[4]
    ld      shift, y+       ;[5]
    dec     cnt             ;[7]
    brne    txByteLoop      ;[8]
;make SE0:
    cbr     x1, USBMASK     ;[9] подготовка SE0 [спецификация говорит, что EOP может быть от 25 до 30 циклов]
    lds     x2, usbNewDeviceAddr;[10]
    lsl     x2              ;[12] мы сравниваем с влево сдвинутым адресом
    out     USBOUT, x1      ;[13] <-- вывод SE0 -- теперь от 2 бит = 22 пока шина в состоянии ожидания (idle)
    subi    YL, 20 + 2      ;[0] только назначает адрес на пакеты данных, нет ACK/NAK в x3
    sbci    YH, 0           ;[1]
;2006-03-06: перенесена передача нового адреса в usbDeviceAddr из кода C в ассемблер:
;установка адреса только после того, как пакет данных отправлен, не после рукопожатия (handshake)
    breq    skipAddrAssign  ;[2]
    sts     usbDeviceAddr, x2; если не пропущено: SE0 на один цикл длиннее
skipAddrAssign:
;конец передачи usbDeviceAddress
    ldi     x2, 1<<USB_INTR_PENDING_BIT;[4] int0 произошло во время TX -- очистка флага ожидания очереди
    USB_STORE_PENDING(x2)   ;[5]
    ori     x1, USBIDLE     ;[6]
    in      x2, USBDDR      ;[7]
    cbr     x2, USBMASK     ;[8] установка обоих ножек на ввод
    mov     x3, x1          ;[9]
    cbr     x3, USBMASK     ;[10] конфигурируем отсутствие нагрузочных резисторов (pullup) на обоих ножках
    ldi     x4, 5           ;[11]
se0Delay:
    dec     x4              ;[12] [15] [18] [21] [24]
    brne    se0Delay        ;[13] [16] [19] [22] [25]
    out     USBOUT, x1      ;[26] <-- вывод J (idle) -- окончание SE0 (сигнал EOP)
    out     USBDDR, x2      ;[27] <-- теперь освобождение шины
    out     USBOUT, x3      ;[28] <-- убедимся в том, что нет активных нагрузочных (pull-up) резисторов
    rjmp    doReturn
